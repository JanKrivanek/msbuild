<mxfile host="app.diagrams.net" modified="2024-06-06T15:23:39.872Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36" etag="ZVuzHml6vrKniFoi_BiI" version="24.4.7" type="github">
  <diagram name="Page-1" id="KYUkMzLAdZubMLOFAHTG">
    <mxGraphModel dx="2578" dy="2015" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="ZHasga2VB2cQo_qIorBn-40" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;startArrow=classic;startFill=1;" parent="1" source="ZHasga2VB2cQo_qIorBn-1" target="ZHasga2VB2cQo_qIorBn-34" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-1" value="EntryPoint Node&lt;br&gt;&lt;br&gt;Scheduler&lt;br&gt;&lt;br&gt;In Proc Node" style="whiteSpace=wrap;html=1;aspect=fixed;" parent="1" vertex="1">
          <mxGeometry x="670" y="240" width="120" height="120" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-2" value="MSBuild&lt;br&gt;* Programming language (xml based, .props, .targets)&lt;div&gt;* Build engine (interpreting the MSBuild language)&lt;/div&gt;&lt;div&gt;* Library of common build logic (copying data etc.)&lt;br&gt;* API over the Build engine&lt;/div&gt;&lt;div&gt;* CLI (tool wrapping the API)&lt;/div&gt;&lt;div&gt;* API for manipulation of the MSBuild scripts&lt;br&gt;&lt;/div&gt;&lt;div&gt;* VS -&amp;gt; intercats via the API (the interactive API, Evaluation API and Build API)&lt;br&gt;* Extnesibility&lt;br&gt;&amp;nbsp; &amp;nbsp;* Loggers (built-ins - refer by name, custom - dll)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;* Tasks (built-in - in Build.Tasks; Factories - inline code, binary; Exec task)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;* SDK Resolvers;&amp;nbsp; We discover resolvers from folder next to install location of MSBuild - so MSBuild should be suggested to be installed to restricted location&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;* SDKs - specified within the ptoject element (SDK=&quot;...&quot;) - resolvers are then asked to resolve the sdk based on string; There is as well SDK top level element for same element; It can be specified as part of the import element&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;* BuildResult Cache - Injected via special property within a project that points to the binary that implements the cache&lt;/div&gt;" style="text;html=1;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="-210" y="40" width="460" height="290" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-3" value="The Language&lt;div&gt;Tailored for building, publishing&lt;/div&gt;&lt;div&gt;It&#39;s data driven - much easier to express data (properties, items), than logic&lt;br&gt;&amp;nbsp; &amp;nbsp;(majority of projects actually defines just the data, not the logic)&lt;/div&gt;&lt;div&gt;&#39;Scripts&#39; can be imported&amp;nbsp; - data and logic (data usually in .props, logic usually in .targets - not enforced)&lt;/div&gt;&lt;div&gt;Common build logic is imported as so called &#39;common targets&#39;&lt;/div&gt;&lt;div&gt;Targets (executing unit) - you either manipulate data, or/and execute build tools (tasks)&lt;/div&gt;&lt;div&gt;Tasks - ToolTask ...; Any .Net logic extending the given contract&lt;/div&gt;&lt;div&gt;It has concepts helping achieving builds incrementality (targets and tasks inputs/outputs; skipping based on conditions ....)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" style="text;html=1;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="-210" y="390" width="500" height="200" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-13" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="ZHasga2VB2cQo_qIorBn-4" target="ZHasga2VB2cQo_qIorBn-6" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-4" value=".rsp" style="whiteSpace=wrap;html=1;shape=mxgraph.basic.document" parent="1" vertex="1">
          <mxGeometry x="460" y="350" width="60" height="60" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-5" value="API" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="520" y="240" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-11" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="ZHasga2VB2cQo_qIorBn-6" target="ZHasga2VB2cQo_qIorBn-5" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-6" value="CLI" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="520" y="290" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-9" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="ZHasga2VB2cQo_qIorBn-7" target="ZHasga2VB2cQo_qIorBn-5" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-7" value="VS" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="410" y="240" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-10" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=-0.041;entryY=0.327;entryDx=0;entryDy=0;entryPerimeter=0;" parent="1" source="ZHasga2VB2cQo_qIorBn-5" target="ZHasga2VB2cQo_qIorBn-1" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-27" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="ZHasga2VB2cQo_qIorBn-14" target="ZHasga2VB2cQo_qIorBn-15" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-14" value="User defined import logic&lt;br&gt;&lt;br&gt;(.props/.targets)" style="whiteSpace=wrap;html=1;shape=mxgraph.basic.document" parent="1" vertex="1">
          <mxGeometry x="640" y="370" width="90" height="110" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-15" value=".proj&lt;br&gt;(e.g. Foo.csproj)" style="whiteSpace=wrap;html=1;shape=mxgraph.basic.document" parent="1" vertex="1">
          <mxGeometry x="540" y="380" width="80" height="100" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-17" value="Groups of operations:&lt;br&gt;* Evaluation&lt;div&gt;&amp;nbsp; &amp;nbsp;* Defines the data (props, items)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;* executes all imports (inserts in place content of the imported files)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;* Only R/O in-memory operation (no side effects on disk)&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;* if SDK is involved - we call resolvers - so they can write to disk. E.g Nuget resolver can restore and write packages to disk&lt;br&gt;&amp;nbsp; &amp;nbsp;&lt;br&gt;&lt;br&gt;* Execution of the build (it requires Evaluation to proceed)&lt;/div&gt;&lt;div&gt;&amp;nbsp; * Runs Targets/tasks&lt;/div&gt;&lt;div&gt;&amp;nbsp; * It&#39;s allowed and desired to alter the evaluated model&lt;/div&gt;&lt;div&gt;&amp;nbsp; * It can generate intermediary data/outputs. Both modifications (evaluated model - the MSBuild data in memory; and the physical I/O intermediry data) often happens together; but can happen in isolation as well&lt;/div&gt;&lt;div&gt;&amp;nbsp; * Example - Compiler - it can either discover files itself; or (roslyn) it requires everything on input&lt;/div&gt;&lt;div&gt;&amp;nbsp; * Knowing exhaustively all the inputs and outputs is allowing to implement incrementality logic&lt;/div&gt;" style="shape=callout;whiteSpace=wrap;html=1;perimeter=calloutPerimeter;align=left;position2=0.5;" parent="1" vertex="1">
          <mxGeometry x="470" y="-90" width="520" height="330" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-19" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.94;entryY=0.986;entryDx=0;entryDy=0;entryPerimeter=0;" parent="1" source="ZHasga2VB2cQo_qIorBn-15" target="ZHasga2VB2cQo_qIorBn-5" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-21" value="This can be minimalistic (debugging), but usually contains lot of logic&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;Possible logic that can happen:&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;* Evaluation of env properties&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Globs expansions (scanning/importing from locations; can be wildcarded)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Explicit import of files with logic&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Property/Item functions execution - we have whitelist of things to be used - to prevent side effects. There can be prop functions that can influence reproducivility (e.g. TickCount)&lt;/div&gt;" style="shape=callout;whiteSpace=wrap;html=1;perimeter=calloutPerimeter;position2=0.59;rotation=0;horizontal=1;textDirection=ltr;flipV=1;" parent="1" vertex="1">
          <mxGeometry x="360" y="480" width="320" height="280" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-29" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.955;entryY=1.021;entryDx=0;entryDy=0;entryPerimeter=0;" parent="1" source="ZHasga2VB2cQo_qIorBn-23" target="ZHasga2VB2cQo_qIorBn-15" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="685" y="490" />
              <mxPoint x="685" y="482" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-23" value="&amp;lt;..&amp;gt;.g.props from obj folder (IntermediaryOutputPath)&lt;br&gt;&lt;br&gt;Can be injected from nugets during restore" style="whiteSpace=wrap;html=1;shape=mxgraph.basic.document" parent="1" vertex="1">
          <mxGeometry x="750" y="370" width="140" height="150" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-24" value="&quot;Installed&quot; logic&lt;br&gt;(&quot;Common targets&quot;)&lt;br&gt;SDK + VS" style="whiteSpace=wrap;html=1;shape=mxgraph.basic.document" parent="1" vertex="1">
          <mxGeometry x="740" y="530" width="120" height="120" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-28" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="ZHasga2VB2cQo_qIorBn-25" target="ZHasga2VB2cQo_qIorBn-15" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-25" value="User specific imports" style="whiteSpace=wrap;html=1;shape=mxgraph.basic.document" parent="1" vertex="1">
          <mxGeometry x="310" y="385" width="120" height="120" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-26" value="ENV&lt;br&gt;Registry" style="shape=cylinder3;whiteSpace=wrap;html=1;boundedLbl=1;backgroundOutline=1;size=15;" parent="1" vertex="1">
          <mxGeometry x="350" y="280" width="60" height="80" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-30" value="MSBuild doesn&#39;t read registry, but there are PropFunctions that can" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="260" y="210" width="130" height="80" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-31" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.62;entryY=0.999;entryDx=0;entryDy=0;entryPerimeter=0;" parent="1" source="ZHasga2VB2cQo_qIorBn-24" target="ZHasga2VB2cQo_qIorBn-15" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="730" y="590" />
              <mxPoint x="730" y="500" />
              <mxPoint x="590" y="500" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-33" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="ZHasga2VB2cQo_qIorBn-32" target="ZHasga2VB2cQo_qIorBn-5" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="325" y="220" />
              <mxPoint x="550" y="220" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-32" value="Extensibility&lt;br&gt;Loggers(dlls)&lt;br&gt;Tasks(dlls or code)&lt;div&gt;Resolvers (fixed location)&lt;br&gt;SDKs&lt;br&gt;Cache&lt;br&gt;Checks&lt;/div&gt;" style="whiteSpace=wrap;html=1;shape=mxgraph.basic.document" parent="1" vertex="1">
          <mxGeometry x="255" y="40" width="140" height="150" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-34" value="Worker Node" style="whiteSpace=wrap;html=1;aspect=fixed;" parent="1" vertex="1">
          <mxGeometry x="970" y="250" width="80" height="80" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-35" value="Worker Node" style="whiteSpace=wrap;html=1;aspect=fixed;" parent="1" vertex="1">
          <mxGeometry x="980" y="260" width="80" height="80" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-42" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;startArrow=classic;startFill=1;" parent="1" source="ZHasga2VB2cQo_qIorBn-36" target="ZHasga2VB2cQo_qIorBn-37" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-36" value="Worker Node" style="whiteSpace=wrap;html=1;aspect=fixed;" parent="1" vertex="1">
          <mxGeometry x="990" y="270" width="80" height="80" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-37" value="Task Host" style="whiteSpace=wrap;html=1;aspect=fixed;" parent="1" vertex="1">
          <mxGeometry x="1200" y="260" width="80" height="80" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-39" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="ZHasga2VB2cQo_qIorBn-38" target="ZHasga2VB2cQo_qIorBn-5" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-38" value="Nuget Client" style="whiteSpace=wrap;html=1;aspect=fixed;" parent="1" vertex="1">
          <mxGeometry x="1080" y="75" width="80" height="80" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-41" value="IPC" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="850" y="250" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-43" value="Single Project Build - no parallelism. Everything sequentially (Evaluation then exec - target by target; task by task)&lt;br&gt;&lt;br&gt;Executing Task - There needs to be &amp;lt;UsingTask&amp;gt; elelemtn - to know the dll and class to load. The MSBuild XML can define additional attributes for xml. Logic will map those from xml to the properties in the implementation; make sure to initialize data and then call Execute method&lt;br&gt;&lt;br&gt;UsingTask can define other requirements - e.g. runtime/bitness constraints - those are satisfied with TaskHost process&lt;br&gt;&lt;br&gt;TaskHost execution can be explicitly opted in - to sandbox execution; and to prevent locking of files by long living nodes (and when something need to be build and loaded during the same build)&lt;br&gt;&lt;br&gt;&lt;br&gt;Multi Proj" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="1040" y="540" width="460" height="290" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-44" value="IPC (...)" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="1110" y="320" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-45" value="MSBuild Server" style="whiteSpace=wrap;html=1;aspect=fixed;" parent="1" vertex="1">
          <mxGeometry x="1350" y="10" width="80" height="80" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-47" value="Diagnosibility - logs, etw, telemetry&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Historically there was a debugger&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Current phylosophy - better logs (that way you can troubleshoot CI buils same as local builds)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp; (this has overhead though)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* There is logging API allowing to log from Tasks, plus there is logging emitted within the engine&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* The logging events need to be serializable (in 2 ways - node2node and node2binlog)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* This is pluggable - you can receive events via event handlers&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;- specified on commandline, or via API (CLI just wraps the API here)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp; - plus there is env var for binlog&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* plus builtin - binlog, consol log, file logs, terminal log&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Engine writes some ETW&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Today we have Telemetry consumer only in SDK, not in VS&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* There used to be VS telemetry, but it was removed during open sourcing&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* in SDk we created new which is a form of a logger and sinks it to sdk&lt;/div&gt;" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="70" y="-610" width="540" height="270" as="geometry" />
        </mxCell>
        <mxCell id="ZHasga2VB2cQo_qIorBn-48" value="NEXT:&lt;br&gt;Diagnosibility&lt;br&gt;IPC&lt;br&gt;Paralelism&lt;br&gt;VS scenarios specific&lt;br&gt;Restore&lt;br&gt;MsBuild Server&lt;br&gt;Graph Build&lt;br&gt;Project Caching" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="810" y="730" width="200" height="160" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-5" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;startArrow=classic;startFill=1;" edge="1" parent="1" source="2RyIAvp03iyWgmpoY47I-1" target="ZHasga2VB2cQo_qIorBn-45">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-6" value="IPC" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" vertex="1" connectable="0" parent="2RyIAvp03iyWgmpoY47I-5">
          <mxGeometry x="-0.1278" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-1" value="MSBuild.exe" style="rounded=0;whiteSpace=wrap;html=1;rotation=90;" vertex="1" parent="1">
          <mxGeometry x="1225" y="30" width="90" height="40" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-3" value="This is scheduler, Entrypont node, inproc node ..." style="shape=callout;whiteSpace=wrap;html=1;perimeter=calloutPerimeter;" vertex="1" parent="1">
          <mxGeometry x="1340" y="-70" width="120" height="80" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-10" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.631;entryY=1.111;entryDx=0;entryDy=0;entryPerimeter=0;exitX=0.167;exitY=-0.012;exitDx=0;exitDy=0;exitPerimeter=0;" edge="1" parent="1" source="2RyIAvp03iyWgmpoY47I-11" target="ZHasga2VB2cQo_qIorBn-41">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="750" y="833" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-9" value="Main node asks for results&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;Engine doesn&#39;t know about projects references, it knows about projects&lt;div&gt;PreojectReference item is not special&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;in the Task API there is an API to tell that task is blocked on results&lt;/div&gt;&lt;div&gt;That helps common targets to implement the handling project references&lt;/div&gt;&lt;div&gt;(via &quot;ProjectReference protocol&quot;)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="-90" y="810" width="410" height="190" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-11" value="ALL 1st class citizen IPCs in MSBuild:&lt;br&gt;&lt;br&gt;Transport layer &lt;br&gt;NamedPipes - Win Named pipes on Wins and wrapper around sockets on Unix&lt;div&gt;The unix named pipe implementation comes from BCL&lt;/div&gt;&lt;div&gt;In Windows we use ACL (for curent user) + elevation to indicate who can connect&amp;nbsp;&lt;/div&gt;&lt;div&gt;Naming - MSBuild + proc id (windows)&lt;/div&gt;&lt;div&gt;Unix - the namespace is same for files and pipes - so we create pipe in&amp;nbsp; temp (we observe $temp var), we first create subfolder for current user with proper access settings (as temp can be shared in nix)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Message layer&lt;br&gt;Custom serialization implemented by MSBuild (&#39;ITranslatable&#39;)&lt;br&gt;Technicaly we can easily onboard any existing state of the art messages serialization (protobufs, messagepack, grps ...)&lt;/div&gt;&lt;div&gt;Previously we supported custom data transmission (custom events, exceptions ...)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Binary log de/serialization - is in fact logically very similar&lt;/div&gt;" style="text;html=1;align=left;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="500" y="903" width="1090" height="260" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-12" value="Caches (serialization)&lt;div&gt;&lt;br&gt;* RAR cache&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; - can write to disk (custom de/ser?)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;* RegisterTaskObject - you can share state in a build or between builds via API. E.g git coommit can be shared&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - this is per node only&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - you can choose the life scope - per build or &#39;forewer&#39;. No serialization&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;* We allow COM IPC via TaskHostObject&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;* Project result cache - it is in-memory, but can be stored to disk as well&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; - we store to disk in case of too many results (&#39;memory pressure&#39;) - kind of &#39;swap&#39;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;- persistnet within the boundaries in a single build&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;- it is pluged in via special item that points to path to load (so that it can be injected via nugets)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;- this plugs into the Scheduler, so that it can provide results without running the project&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;- when request to build is received - we first look into the cache and pend the request only if it is not contained&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;- the targetcan specify Return and Output attributes that specifies serialization of those ites&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;- so result of a project is&amp;nbsp; the outputs/returns of the requested targets on a project (from build request) + success/failuer&lt;/div&gt;&lt;div&gt;&amp;nbsp; - but, the actual files written during the build need to be cached as well - so it needs to track all inputs and outputs of projects &lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;(via I/O redirection) - (this is the &#39;Gen2 build cache&#39;)&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;* &#39;Project Cache Plugin&#39; - plugin to allow persistent cachign of results between builds (Cloud build e.g.)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;* Incremental build is cache by itself (stored in obj) - managed via targets/tasks inputs/outputs&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" style="text;html=1;align=left;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="-160" y="1125" width="690" height="400" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-13" value="Scheduler&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Build starts with entrypoint. Scheduler assigns it to node&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Influence of other projects&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp;- e.g. via files (transparent to MSBuild)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Project has 1 - multiple targets (invisible to schedluler)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Schdeuler sees pending requests&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* If you call MSBuild task - talks to scheduler and asks for results&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* MSBuild task is special handled - it calls MSBuild task implementation directly&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp; it calls IBuildEngine&amp;nbsp; -&amp;gt; BuildProject - that constructs request that is communiated to the scheduler&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp; during that node can execute other work (slightly different mechanics that explicitly Yielding from task - but result is same)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Scheduler satisfies results either from existing results or it queues it&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Whenever node is done - scheduler decides to assign new work to it&lt;/div&gt;" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="510" y="1240" width="680" height="200" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-14" value="Nuget can use Graph via API" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="1090" y="-60" width="100" height="80" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-15" value="VS an Nuget uses API same as any other API user (no &#39;friendly&#39; access)" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="140" y="-210" width="160" height="90" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-16" value="Parallelism and its granularity&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Project can stop only when it&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Paralelism is at project level; each project is single threaded (untill done or Yield - which is explicit from task or from within MSBuild task)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* This level is not good enough for some scenarios - e.g. C++ compilation (each file has it&#39;s object file)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* This can be workarounded via custom paralelism - but hten it&#39;s not controled via /m parameter (you can end up with m nodes, and each trying to run m threads)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Competing build mechanism can control and saturate the amount of threads across whole machine (not oversubmit)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Other scenario - Link build time code generation&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Other level of paralelism could have been targets. Targets are basically nodes in a graph - so technically we could do parallel topo walkthrough. But we do single threaded&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Currently the order of specification of dependencies is observed - so paralelizing might break this&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Paralelization could introduce nondeterminsm - becouse some of the dependency specification is not &#39;all&#39; but &#39;any of&#39; (e.g. &#39;BeforeTargets&#39; - on any of those hit)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Tasks - currently run sequential as well&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* (C++ can do a paralel graph build of tasks)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* no need to paralelize here&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;Batching -&amp;gt; way of multiplication of execution of targets or tasks. Done via items and way of referencing thos from within&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp; - this is not paralelilzed today (technically could)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;Target is as well the unit of incrementality (so all of the tasks within the target (based on conditions) are run when target is run)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;This means - today paralelization need to be done on level of projects&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;Multitargeting - done via outer build, that constructs a list of same project x times, each time with different metadata (TFM, runtime...)&lt;/div&gt;" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="860" y="-810" width="610" height="530" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-18" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1;entryY=0.75;entryDx=0;entryDy=0;" edge="1" parent="1" source="2RyIAvp03iyWgmpoY47I-17" target="ZHasga2VB2cQo_qIorBn-1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="920" y="470" />
              <mxPoint x="920" y="330" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-17" value="Loggers" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="940" y="440" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-19" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.192;entryY=0.99;entryDx=0;entryDy=0;entryPerimeter=0;" edge="1" parent="1" source="2RyIAvp03iyWgmpoY47I-17" target="ZHasga2VB2cQo_qIorBn-36">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="2RyIAvp03iyWgmpoY47I-20" value="Graph Build&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* When building &#39;normally&#39; - all deps are discoverd just-in-time&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* This can limit paralelism (due to late discoverability), caching can get complicated&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Other systems historicaly buld on top of msbuild a graph of projects - so that it could be build in isolation (not building referenced projects)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;- (this is doen via &#39;BuildProjectReferences=false&#39;)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* VS does thartt as well - as it knows graph up front&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* currently there are -graph operations (inspired and&amp;nbsp; authored by CloudBuild)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;Mechanism&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* All projects are evaulated upfront&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Graph build needs to treat ProjectReference as special thing (standard build takes it just as any other item)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* This can then e.g. be used by nugetrestore&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Graph scheduler auguments the scheduler - so it requests builds of projects as it sees necessary by the constructed graph&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* There are 2 modes of strictness&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp;- &#39;standard&#39; - which uses project result cache - so if project references something unexpected - it&#39;ll just schedule that other project (so very similar to standard build - just attempts to start from leaves, not entrypoint project)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp;- strict mode - via &#39;-isolate&#39; - all the dependencies needs to be captured upfront. Cache miss leads to failure&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* With graph isolate - you need to specify input results cache and output results cache - so that the results from targets of different (referenced) &lt;br&gt;projects can be accessed/exchange within the build than can theoretically be freely distributed on the project granularity level&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - the caches are pluggable (api), the receive and give back blobs (per project)&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - the msbuild takes care about de/serialization of those results - but it&#39;s the same thing that already needs to be doen for sending results from WorkerNodes to the Scheduler and it&#39;s results cache&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;* Graph hasen&#39;t been historically 1st class citizen - in future it might be nice evolution (especially together with msbuild server and it&#39;s caching potential)&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/div&gt;" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry y="1535" width="1200" height="370" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
